#!/usr/bin/env python 

import re
import string
import random
import hashlib
import sys
import pwn

from Crypto.Cipher import AES

host = "127.0.0.1"
port = 3336
user = b"flag"

if len(sys.argv)>3:
  host = sys.argv[1]
  port = sys.argv[2]
  user = sys.argv[3].encode()

#master_hash = bytearray([80, 67, 14, 211, 155, 40, 218, 226, 90, 162, 233, 139, 75, 145, 7, 181])
master_hash = b"\x50\x43\x0e\xd3\x9b\x28\xda\xe2\x5a\xa2\xe9\x8b\x4b\x91\x07\xb5"
secret = b"PRENEELAPPROVESMAYBE"
wait_for_prompt = True
#wait_for_prompt = False

def unpack_moves( buffer ):
    ret = []
    movemap = [b"w", b"n", b"s", b"e"]
    for value in buffer:
        for j in range(0, 4):
            n = ((value >> j*2) & 3)
            ret.append(movemap[n])
    return ret
  
def dohash_inverse( buffer, iv=None ):
    key = hashlib.sha1(secret).digest()[0:16]
    if iv is None:
        iv = key
    cipher = AES.new( key, AES.MODE_CBC, iv )
    return cipher.decrypt( buffer )[0:16]
    
def create_forward_secure_tokens_inverse( buffer, epoch ):
    buff = buffer
    plain_block = b"\x55"*16 #0x55:nnnn packed, can be anything in practice
    for x in range(1, epoch):
        buff = dohash_inverse(buff)
    buff = dohash_inverse(buff, plain_block);
    buff = dohash_inverse(buff);
    return buff + plain_block

r = pwn.remote(host, port)
epoch = r.recvregex(b"Your epoch is: ([0-9]+)\.\n", capture=True)[1]
pwn.log.info(f"Found epoch: {epoch.decode()}")
packed = create_forward_secure_tokens_inverse(master_hash, int(epoch))
new_user = "".join(random.choice(string.ascii_uppercase + string.digits) for _ in range(8)).encode()
new_pass = b"anything"
new_secr = b"anything"
pwn.log.info(f"Creating new dummy user: {new_user}")
r.recvuntil( b"Insert Username: " )
r.write( new_user + b'\n' )
r.recvuntil( b"Insert Password: " )
r.write( new_pass + b'\n' )
r.recvuntil( b"Insert a secret to register: " )
r.write( new_secr + b'\n' )
r.recvuntil( b"\n?>" )
r.write( b"p\n"  )
with pwn.log.progress('Sending directions') as p:
    i = 0
    unpacked = unpack_moves(packed)
    for move in unpacked:
        i += 1
        p.status(f"{i} / {len(unpacked)}")
        if wait_for_prompt:
            r.recvuntil( b"Next move? [w,n,e,s]" )
        r.write( move + b"\n" )
r.recvuntil( b"Which user's secret are you looking for?\n?>" )
r.write( user + b"\n" )
secret=r.recv()
pwn.log.info(f"Found secret: {secret.decode()}")
