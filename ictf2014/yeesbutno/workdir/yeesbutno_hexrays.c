/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2014 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int init_proc();
// int __fastcall AES_set_encrypt_key(_QWORD, _QWORD, _QWORD); weak
// void *memset(void *s, int c, size_t n);
// int close(int fd);
// int __gmon_start__(void); weak
// uint16_t htons(uint16_t hostshort);
// void __noreturn exit(int status);
// void __noreturn __assert_fail(const char *assertion, const char *file, unsigned int line, const char *function);
// int __fastcall AES_cbc_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
// int strncmp(const char *s1, const char *s2, size_t n);
// void *malloc(size_t size);
// ssize_t recv(int fd, void *buf, size_t n, int flags);
// int setsockopt(int fd, int level, int optname, const void *optval, socklen_t optlen);
// size_t strnlen(const char *string, size_t maxlen);
// void free(void *ptr);
// size_t strlen(const char *s);
// int pthread_create(pthread_t *newthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg);
// int listen(int fd, int n);
// int __fastcall SHA1(_QWORD, _QWORD, _QWORD); weak
// int sprintf(char *s, const char *format, ...);
// unsigned int sleep(unsigned int seconds);
// int atoi(const char *nptr);
// __sighandler_t signal(int sig, __sighandler_t handler);
// int socket(int domain, int type, int protocol);
// ssize_t send(int fd, const void *buf, size_t n, int flags);
// int pthread_detach(pthread_t th);
// int memcmp(const void *s1, const void *s2, size_t n);
// void *calloc(size_t nmemb, size_t size);
// char *strncpy(char *dest, const char *src, size_t n);
// int bind(int fd, const struct sockaddr *addr, socklen_t len);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// uint32_t htonl(uint32_t hostlong);
// int pthread_mutex_lock(pthread_mutex_t *mutex);
// void perror(const char *s);
// int rand(void);
// int fprintf(FILE *stream, const char *format, ...);
// int accept(int fd, struct sockaddr *addr, socklen_t *addr_len);
// int pthread_mutex_unlock(pthread_mutex_t *mutex);
// void *memcpy(void *dest, const void *src, size_t n);
// time_t time(time_t *timer);
signed int deregister_tm_clones();
int register_tm_clones();
signed int _do_global_dtors_aux();
int frame_dummy();
void __noreturn kill_handler();
void *execute_service(void *); // idb
void __fastcall __noreturn execute_cleaner(void *a1);
int __cdecl main(int argc, const char **argv, const char **envp);
void joke_the_user(void);
__int64 __fastcall parse_attack(char *a1, signed int a2, char *a3, int a4);
// __int64 __usercall read_moves@<rax>(__int64 fd@<rsi>, __int64 a2@<rdi>, int a3);
signed __int64 __fastcall cred_screen(__int64 a1);
signed __int64 __fastcall menu_screen(__int64 a1);
signed __int64 __fastcall send_secret(__int64 a1);
signed __int64 __fastcall entry_screen(__int64 a1);
__int64 __fastcall min(unsigned int a1, unsigned int a2);
__int64 __fastcall dohash(unsigned __int8 *, unsigned int, unsigned __int8 *); // idb
__int64 create_challenge_1(void); // idb
__int64 __fastcall create_forward_secure_tokens(const unsigned __int8 *, unsigned int, unsigned __int8 *, int); // idb
__int64 __fastcall is_it_valid(unsigned __int8 *a1, __int64 a2, unsigned __int8 *a3, unsigned int a4, int a5);
__int64 __fastcall convert_moves_to_buffer(char *, unsigned int, unsigned __int8 *, unsigned int *); // idb
__int64 __fastcall vulnerable_function1(char *, int); // idb
__int64 init_db(void); // idb
__int64 __fastcall get_hash(char *); // idb
signed __int64 __fastcall add_user(char *a1, const char *a2, char *a3, __int64 a4);
__int64 __fastcall check_cred(char *a1, const char *a2, __int64 a3);
int __fastcall remove_older_than(int a1);
__int64 __fastcall get_user_cred(char *); // idb
void set_init_epoch(void);
__int64 get_current_epoch(void); // idb
void *__fastcall recv_str(__int64 a1);
int __fastcall _libc_csu_init(unsigned int a1, __int64 a2, __int64 a3);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

__int64 (__fastcall *_frame_dummy_init_array_entry[2])() = { &frame_dummy, &_do_global_dtors_aux }; // weak
__int64 (__fastcall *_do_global_dtors_aux_fini_array_entry)() = &_do_global_dtors_aux; // weak
char *INVALID_MOVEMENT = "\nNot a valid choise!"; // idb
char *NEXT_MOVEMENT = "\nNext move? [w,n,e,s]"; // idb
_QWORD DISCOVER_MESSAGES[] = { 4209487LL }; // weak
char *SQL_FAKE_ERR = "There seems to be an error in your SQL query. The MySQL server error output below, if there is any, may also help you in diagnosing the problem\nERROR: Unclosed quote @ 1\nSTR: \"\nSQL: \""; // idb
_QWORD PROBABILITIES = 171798691840LL; // weak
_QWORD DISCOVER_FUNCTIONS[] = { 4200383LL }; // weak
unsigned __int8 master_hash = 80u; // idb
FILE *stderr; // idb
FILE *stdout; // idb
char completed_6972; // weak
int listensd; // idb
int uid; // weak
__int64 ht; // weak
__int64 mt[]; // weak
__int64 oldest; // weak
__int64 newest; // weak
pthread_mutex_t dblock; // idb
int starting_epoch; // weak
// extern _UNKNOWN _gmon_start__; weak


//----- (0000000000400E58) ----------------------------------------------------
int init_proc()
{
  _UNKNOWN *v0; // rax@1

  v0 = &_gmon_start__;
  if ( &_gmon_start__ )
    LODWORD(v0) = __gmon_start__();
  return (signed int)v0;
}
// 400EC0: using guessed type int __gmon_start__(void);

//----- (0000000000401120) ----------------------------------------------------
#error "401126: positive sp value has been found (funcsize=3)"

//----- (0000000000401150) ----------------------------------------------------
signed int deregister_tm_clones()
{
  return 7;
}

//----- (0000000000401180) ----------------------------------------------------
int register_tm_clones()
{
  return 0;
}

//----- (00000000004011C0) ----------------------------------------------------
signed int _do_global_dtors_aux()
{
  signed int result; // eax@2

  if ( !completed_6972 )
  {
    result = deregister_tm_clones();
    completed_6972 = 1;
  }
  return result;
}
// 605538: using guessed type char completed_6972;

//----- (00000000004011E0) ----------------------------------------------------
int frame_dummy()
{
  return register_tm_clones();
}
// 4011E0: could not find valid save-restore pair for rbp

//----- (000000000040120D) ----------------------------------------------------
void __noreturn kill_handler()
{
  close(listensd);
  exit(0);
}

//----- (000000000040122F) ----------------------------------------------------
void *__fastcall execute_service(void *a1)
{
  __int64 v1; // ST08_8@3
  __int64 v2; // ST10_8@3
  bool v3; // al@5
  void *result; // rax@14
  __int64 v5; // rbx@18
  unsigned int v6; // [sp+2Ch] [bp-134h]@3
  unsigned int v7; // [sp+30h] [bp-130h]@8
  int v8; // [sp+34h] [bp-12Ch]@2
  void *ptr; // [sp+38h] [bp-128h]@1
  char v10; // [sp+40h] [bp-120h]@3
  unsigned __int8 v11; // [sp+C0h] [bp-A0h]@8
  __int64 v12; // [sp+148h] [bp-18h]@1

  v12 = *MK_FP(__FS__, 40LL);
  ptr = a1;
  *((_DWORD *)a1 + 2) = (unsigned __int64)get_current_epoch() + 1;
  if ( (unsigned int)cred_screen((__int64)ptr) != 0 )
    goto LABEL_15;
  v8 = menu_screen((__int64)ptr);
  if ( v8 == 1 )
  {
    fwrite("\nCHOOSEN 0\n", 1uLL, 0xBuLL, stderr);
    v1 = *((_QWORD *)ptr + 1);
    v2 = *((_QWORD *)ptr + 2);
    v3 = (unsigned __int8)read_moves((__int64)&v6, (__int64)&v10, *(_QWORD *)ptr) && !(v6 & 3);
    if ( v3 )
    {
      convert_moves_to_buffer(&v10, v6, &v11, &v7);
      if ( (unsigned int)is_it_valid(&master_hash, 16LL, &v11, v7, *((_DWORD *)ptr + 2)) != 0 )
        entry_screen((__int64)ptr);
    }
    goto LABEL_15;
  }
  if ( !v8 )
  {
    fwrite("\nCHOOSEN 0\n", 1uLL, 0xBuLL, stderr);
    send_secret((__int64)ptr);
LABEL_15:
    close(*((_DWORD *)ptr + 1));
    if ( *((_QWORD *)ptr + 2) )
      free(*((void **)ptr + 2));
    free(ptr);
    fwrite("Client has disconnected\n", 1uLL, 0x18uLL, stderr);
    result = 0LL;
    goto LABEL_18;
  }
  close(*((_DWORD *)ptr + 1));
  if ( *((_QWORD *)ptr + 2) )
    free(*((void **)ptr + 2));
  free(ptr);
  fwrite("Client has disconnected\n", 1uLL, 0x18uLL, stderr);
  result = 0LL;
LABEL_18:
  v5 = *MK_FP(__FS__, 40LL) ^ v12;
  return result;
}

//----- (00000000004014C3) ----------------------------------------------------
void __fastcall __noreturn execute_cleaner(void *a1)
{
  while ( 1 )
  {
    sleep(0x4B0u);
    remove_older_than(600);
  }
}

//----- (00000000004014E5) ----------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  uint16_t v3; // ax@13
  int optval; // [sp+10h] [bp-70h]@4
  char arg; // [sp+14h] [bp-6Ch]@4
  socklen_t addr_len; // [sp+18h] [bp-68h]@20
  int v7; // [sp+1Ch] [bp-64h]@4
  int fd; // [sp+20h] [bp-60h]@7
  int v9; // [sp+24h] [bp-5Ch]@20
  pthread_t th; // [sp+28h] [bp-58h]@24
  pthread_t newthread; // [sp+30h] [bp-50h]@4
  void *v12; // [sp+38h] [bp-48h]@24
  __int64 v13; // [sp+40h] [bp-40h]@19
  __int64 v14; // [sp+48h] [bp-38h]@19
  struct sockaddr addr; // [sp+50h] [bp-30h]@13
  struct sockaddr v16; // [sp+60h] [bp-20h]@20
  __int64 v17; // [sp+78h] [bp-8h]@1

  v17 = *MK_FP(__FS__, 40LL);
  if ( argc <= 1 )
  {
    fprintf(stderr, "Usage: %s [port]\n", *argv, argv);
    exit(-1);
  }
  optval = 1;
  v7 = 0;
  init_db();
  set_init_epoch();
  signal(9, (__sighandler_t)kill_handler);
  signal(2, (__sighandler_t)kill_handler);
  signal(3, (__sighandler_t)kill_handler);
  if ( pthread_create(&newthread, 0LL, (void *(*)(void *))execute_cleaner, &arg) != 0 )
  {
    perror("Cannot create another thread\n");
    exit(-1);
  }
  fd = socket(2, 1, 0);
  if ( (unsigned int)fd >> 31 )
  {
    perror("Error in creating a new socket");
    exit(2);
  }
  if ( setsockopt(fd, 1, 2, &optval, 4u) == -1 )
  {
    perror("setsockopt error");
    exit(1);
  }
  addr.sa_family = 2;
  *(_DWORD *)&addr.sa_data[2] = htonl(0);
  v3 = atoi(argv[1]);
  *(_WORD *)&addr.sa_data[0] = htons(v3);
  if ( (unsigned int)bind(fd, &addr, 0x10u) >> 31 )
  {
    perror("Error in binding a new socket");
    exit(-1);
  }
  if ( listen(fd, 50) != 0 )
  {
    perror("Error on listen");
    exit(-1);
  }
  v13 = 10LL;
  v14 = 0LL;
  while ( 1 )
  {
    while ( 1 )
    {
      addr_len = 16;
      v9 = accept(fd, &v16, &addr_len);
      if ( v9 != -1 )
        break;
      perror("Fork has failed, connection has been dropped\n");
      sleep(1u);
    }
    if ( (unsigned int)setsockopt(v9, 1, 20, &v13, 0x10u) >> 31 )
      perror("setsockopt failed\n");
    v12 = malloc(0x18uLL);
    *((_DWORD *)v12 + 1) = v9;
    ++v7;
    *(_DWORD *)v12 = v7;
    *((_QWORD *)v12 + 2) = 0LL;
    if ( pthread_create(&th, 0LL, execute_service, v12) != 0 )
    {
      perror("Cannot create another thread\n");
      sleep(1u);
    }
    else
    {
      pthread_detach(th);
    }
  }
}

//----- (00000000004017BF) ----------------------------------------------------
void joke_the_user(void)
{
  ;
}

//----- (00000000004017C6) ----------------------------------------------------
__int64 __fastcall parse_attack(char *a1, signed int a2, char *a3, int a4)
{
  __int64 result; // rax@15
  signed int v5; // [sp+24h] [bp-Ch]@1
  signed int i; // [sp+24h] [bp-Ch]@8
  signed int v7; // [sp+28h] [bp-8h]@1
  signed int v8; // [sp+2Ch] [bp-4h]@1

  v5 = 0;
  v7 = -1;
  v8 = -1;
  *a3 = 0;
  while ( v5 < a2 )
  {
    if ( a1[v5] == 39 || a1[v5] == 34 )
    {
      v7 = v5;
      break;
    }
    ++v5;
  }
  if ( v7 != -1 )
  {
    for ( i = v7; i < a2; ++i )
    {
      if ( a1[i] == 59 )
      {
        v8 = i;
        break;
      }
    }
  }
  if ( v7 == -1 || v8 == -1 )
  {
    result = 0LL;
  }
  else
  {
    strncpy(a3, &a1[v8], a4);
    result = 1LL;
  }
  return result;
}

//----- (00000000004018A9) ----------------------------------------------------
__int64 __usercall read_moves@<rax>(__int64 fd@<rsi>, __int64 a2@<rdi>, int a3)
{
  size_t v3; // rax@2
  __int64 result; // rax@3
  signed int v5; // eax@9
  size_t v6; // rax@20
  unsigned int v7; // ST28_4@25
  size_t v8; // rax@37
  size_t v9; // rax@44
  size_t v10; // rax@48
  size_t v11; // rax@55
  __int64 v12; // rbx@67
  signed int v13; // [sp+14h] [bp-47Ch]@1
  unsigned int v14; // [sp+18h] [bp-478h]@25
  int v15; // [sp+1Ch] [bp-474h]@1
  int v16; // [sp+20h] [bp-470h]@1
  unsigned int i; // [sp+24h] [bp-46Ch]@27
  signed int v18; // [sp+2Ch] [bp-464h]@8
  int v19; // [sp+30h] [bp-460h]@25
  int v20; // [sp+34h] [bp-45Ch]@25
  void (__fastcall *v21)(int *, signed __int64); // [sp+38h] [bp-458h]@4
  char *s; // [sp+40h] [bp-450h]@29
  void *ptr; // [sp+48h] [bp-448h]@1
  char v24; // [sp+50h] [bp-440h]@25
  char string; // [sp+70h] [bp-420h]@43
  __int64 v26; // [sp+478h] [bp-18h]@1

  v26 = *MK_FP(__FS__, 40LL);
  v13 = 0;
  v15 = 0;
  v16 = 0;
  ptr = 0LL;
  *(_DWORD *)fd = 0;
  *(_BYTE *)a2 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      if ( v13 > 127 )
      {
        *(_DWORD *)fd = v13;
        if ( ptr )
          free(ptr);
        result = 1LL;
        goto LABEL_67;
      }
      v3 = strlen(NEXT_MOVEMENT);
      if ( send(*(&a3 + 1), NEXT_MOVEMENT, v3, 0x4000) <= 0 )
      {
        perror("Error on send.");
        result = 0LL;
        goto LABEL_67;
      }
      v21 = 0LL;
      if ( ptr )
        free(ptr);
      ptr = recv_str((__int64)&a3);
      if ( !ptr )
      {
        *(_DWORD *)fd = 0;
        result = 0LL;
        goto LABEL_67;
      }
      v18 = strlen((const char *)ptr);
      if ( v18 != 1 )
        break;
      v5 = *(_BYTE *)ptr;
      if ( v5 == 110 )
      {
        ++v16;
        goto LABEL_25;
      }
      if ( v5 > 110 )
      {
        if ( v5 == 115 )
        {
          --v16;
        }
        else
        {
          if ( v5 != 119 )
            goto LABEL_20;
          --v15;
        }
LABEL_25:
        v7 = (unsigned int)time(0LL) / 0x258;
        v19 = v16;
        v20 = v15;
        SHA1(&v19, 8LL, &v24);
        v14 = *(_DWORD *)&v24 % 0x64u;
        if ( (*(_DWORD *)&v24 % 0x64u & 0x80000000) != 0 )
          v14 = -v14;
        for ( i = 0; i < 0x12uLL; ++i )
        {
          if ( i == 17LL )
          {
            v21 = (void (__fastcall *)(int *, signed __int64))DISCOVER_FUNCTIONS[(unsigned __int64)i];
            s = (char *)DISCOVER_MESSAGES[(unsigned __int64)i];
            break;
          }
          if ( *((_DWORD *)&PROBABILITIES + i) <= (signed int)v14
            && *((_DWORD *)&PROBABILITIES + i + 1) >= (signed int)v14 )
          {
            v21 = (void (__fastcall *)(int *, signed __int64))DISCOVER_FUNCTIONS[(unsigned __int64)i];
            s = (char *)DISCOVER_MESSAGES[(unsigned __int64)i];
            break;
          }
        }
        if ( v21 )
          v21(&v19, 8LL);
        v8 = strlen(s);
        if ( send(*(&a3 + 1), s, v8, 0x4000) <= 0 )
        {
          perror("Error on send.");
          if ( ptr )
            free(ptr);
          result = 0LL;
          goto LABEL_67;
        }
        *(_BYTE *)(a2 + v13++) = *(_BYTE *)ptr;
      }
      else
      {
        if ( v5 == 101 )
        {
          ++v15;
          goto LABEL_25;
        }
LABEL_20:
        v6 = strlen(INVALID_MOVEMENT);
        if ( send(*(&a3 + 1), INVALID_MOVEMENT, v6, 0x4000) <= 0 )
        {
          perror("Error on send.");
          if ( ptr )
            free(ptr);
          result = 0LL;
          goto LABEL_67;
        }
      }
    }
    if ( v18 <= 1 )
      break;
    if ( (unsigned __int8)parse_attack((char *)ptr, 1024, &string, 1024) )
    {
      v9 = strlen(SQL_FAKE_ERR);
      if ( send(*(&a3 + 1), SQL_FAKE_ERR, v9, 0x4000) <= 0 )
      {
        perror("Error on send.");
        if ( ptr )
          free(ptr);
        result = 0LL;
      }
      else
      {
        v10 = strnlen(&string, 0x400uLL);
        if ( send(*(&a3 + 1), &string, v10, 0x4000) <= 0 )
        {
          perror("Error on send.");
          if ( ptr )
            free(ptr);
          result = 0LL;
        }
        else
        {
          *(_DWORD *)fd = v13;
          if ( ptr )
            free(ptr);
          result = 0LL;
        }
      }
      goto LABEL_67;
    }
    v11 = strlen(INVALID_MOVEMENT);
    if ( send(*(&a3 + 1), INVALID_MOVEMENT, v11, 0x4000) <= 0 )
    {
      perror("Error on send.");
      if ( ptr )
        free(ptr);
      result = 0LL;
      goto LABEL_67;
    }
  }
  *(_DWORD *)fd = v13;
  fwrite("\nReceive has failed.\n", 1uLL, 0x15uLL, stdout);
  if ( ptr )
    free(ptr);
  result = 0LL;
LABEL_67:
  v12 = *MK_FP(__FS__, 40LL) ^ v26;
  return result;
}
// 400FB0: using guessed type int __fastcall SHA1(_QWORD, _QWORD, _QWORD);
// 605360: using guessed type _QWORD DISCOVER_MESSAGES[];
// 605400: using guessed type _QWORD PROBABILITIES;
// 605460: using guessed type _QWORD DISCOVER_FUNCTIONS[];

//----- (0000000000401ED1) ----------------------------------------------------
signed __int64 __fastcall cred_screen(__int64 a1)
{
  size_t v1; // rax@1
  signed __int64 result; // rax@2
  size_t v3; // rax@5
  size_t v4; // rax@10
  __int64 v5; // rbx@23
  unsigned int v6; // [sp+14h] [bp-49Ch]@9
  char *string; // [sp+18h] [bp-498h]@12
  void *ptr; // [sp+20h] [bp-490h]@3
  void *v9; // [sp+28h] [bp-488h]@7
  char buf[32]; // [sp+30h] [bp-480h]@1
  char v11[64]; // [sp+50h] [bp-460h]@1
  char s; // [sp+90h] [bp-420h]@1
  __int64 v13; // [sp+498h] [bp-18h]@1

  v13 = *MK_FP(__FS__, 40LL);
  strcpy(buf, "Insert Password: ");
  strcpy(v11, "No user present in DB found. Insert a secret to register: ");
  sprintf(&s, "Your epoch is: %i.\nInsert Username: ", *(_DWORD *)(a1 + 8));
  v1 = strlen(&s);
  if ( send(*(_DWORD *)(a1 + 4), &s, v1, 0x4000) <= 0 )
  {
    result = 0xFFFFFFFFLL;
    goto LABEL_23;
  }
  ptr = recv_str(a1);
  if ( ptr == 0LL )
  {
    result = 0xFFFFFFFFLL;
    goto LABEL_23;
  }
  v3 = strlen(buf);
  if ( send(*(_DWORD *)(a1 + 4), buf, v3, 0x4000) <= 0 )
  {
    result = 0xFFFFFFFFLL;
    goto LABEL_23;
  }
  v9 = recv_str(a1);
  if ( v9 == 0LL )
  {
    free(ptr);
    result = 0xFFFFFFFFLL;
    goto LABEL_23;
  }
  v6 = check_cred((char *)ptr, (const char *)v9, a1 + 16);
  if ( (v6 & 0x80000000) == 0 )
    goto LABEL_20;
  v4 = strlen(v11);
  if ( send(*(_DWORD *)(a1 + 4), v11, v4, 0x4000) <= 0 )
  {
    free(ptr);
    free(v9);
    result = 0xFFFFFFFFLL;
    goto LABEL_23;
  }
  string = (char *)recv_str(a1);
  if ( string == 0LL )
  {
    free(ptr);
    free(v9);
    result = 0xFFFFFFFFLL;
    goto LABEL_23;
  }
  if ( strnlen(string, 0x400uLL) )
  {
    v6 = add_user((char *)ptr, (const char *)v9, string, a1 + 16);
    free(ptr);
    free(v9);
    if ( string )
      free(string);
LABEL_20:
    if ( v6 )
      result = 0xFFFFFFFFLL;
    else
      result = 0LL;
    goto LABEL_23;
  }
  if ( string )
    free(string);
  free(ptr);
  free(v9);
  result = v6;
LABEL_23:
  v5 = *MK_FP(__FS__, 40LL) ^ v13;
  return result;
}

//----- (000000000040229B) ----------------------------------------------------
signed __int64 __fastcall menu_screen(__int64 a1)
{
  size_t v1; // rax@1
  signed __int64 result; // rax@2
  __int64 v3; // rbx@12
  char *v4; // [sp+18h] [bp-68h]@3
  char s[8]; // [sp+20h] [bp-60h]@1
  __int64 v6; // [sp+68h] [bp-18h]@1

  v6 = *MK_FP(__FS__, 40LL);
  strcpy(s, "Do you want to (p)lay.\nDo you want to see your (s)ecret\n?>");
  v1 = strlen(s);
  if ( send(*(_DWORD *)(a1 + 4), s, v1, 0x4000) <= 0 )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v4 = (char *)recv_str(a1);
    if ( v4 == 0LL )
    {
      result = 0xFFFFFFFFLL;
    }
    else if ( strlen(v4) <= 1 )
    {
      if ( *v4 == 115 )
      {
        free(v4);
        result = 0LL;
      }
      else if ( *v4 == 112 )
      {
        free(v4);
        result = 1LL;
      }
      else
      {
        free(v4);
        result = 0xFFFFFFFFLL;
      }
    }
    else
    {
      free(v4);
      result = 0xFFFFFFFFLL;
    }
  }
  v3 = *MK_FP(__FS__, 40LL) ^ v6;
  return result;
}

//----- (000000000040240D) ----------------------------------------------------
signed __int64 __fastcall send_secret(__int64 a1)
{
  size_t v1; // rax@1
  signed __int64 result; // rax@2

  v1 = strlen((const char *)(*(_QWORD *)(a1 + 16) + 2062LL));
  if ( send(*(_DWORD *)(a1 + 4), (const void *)(*(_QWORD *)(a1 + 16) + 2062LL), v1, 0x4000) <= 0 )
    result = 0xFFFFFFFFLL;
  else
    result = 0LL;
  return result;
}

//----- (000000000040246C) ----------------------------------------------------
signed __int64 __fastcall entry_screen(__int64 a1)
{
  size_t v1; // rax@1
  signed __int64 result; // rax@2
  size_t v3; // rax@7
  __int64 v4; // rbx@10
  char *v5; // [sp+10h] [bp-60h]@3
  __int64 v6; // [sp+18h] [bp-58h]@5
  char s[8]; // [sp+20h] [bp-50h]@1
  __int64 v8; // [sp+58h] [bp-18h]@1

  v8 = *MK_FP(__FS__, 40LL);
  strcpy(s, "Which user's secret are you looking for?\n?>");
  v1 = strlen(s);
  if ( send(*(_DWORD *)(a1 + 4), s, v1, 0x4000) <= 0 )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v5 = (char *)recv_str(a1);
    if ( v5 == 0LL )
    {
      result = 0xFFFFFFFFLL;
    }
    else
    {
      v6 = get_user_cred(v5);
      if ( v6 == 0 )
      {
        result = 0xFFFFFFFFLL;
      }
      else
      {
        v3 = strlen((const char *)(v6 + 2062));
        if ( send(*(_DWORD *)(a1 + 4), (const void *)(v6 + 2062), v3, 0x4000) != 0 )
          result = 0xFFFFFFFFLL;
        else
          result = 0LL;
      }
    }
  }
  v4 = *MK_FP(__FS__, 40LL) ^ v8;
  return result;
}

//----- (00000000004025B9) ----------------------------------------------------
__int64 __fastcall min(unsigned int a1, unsigned int a2)
{
  __int64 result; // rax@2

  if ( (signed int)a1 <= (signed int)a2 )
    result = a1;
  else
    result = a2;
  return result;
}

//----- (00000000004025D5) ----------------------------------------------------
__int64 __fastcall dohash(unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3)
{
  size_t v3; // rax@7
  __int64 result; // rax@7
  __int64 v5; // rbx@7
  unsigned __int8 *dest; // [sp+8h] [bp-188h]@1
  unsigned int size; // [sp+28h] [bp-168h]@1
  void *v8; // [sp+30h] [bp-160h]@3
  void *s; // [sp+38h] [bp-158h]@5
  char v10; // [sp+40h] [bp-150h]@7
  char v11; // [sp+140h] [bp-50h]@7
  char v12[8]; // [sp+160h] [bp-30h]@1
  __int64 v13; // [sp+178h] [bp-18h]@1

  dest = a3;
  v13 = *MK_FP(__FS__, 40LL);
  strcpy(v12, "PRENEELAPPROVESMAYBE");
  size = 16 * (a2 / 0x10);
  if ( a2 % 0x10 )
    size += 16;
  v8 = malloc(size);
  if ( !v8 )
    __assert_fail(
      "encrypted != __null",
      "ubersecurecrypt.cpp",
      0x2Bu,
      "int dohash(unsigned char*, unsigned int, unsigned char*)");
  s = malloc(size);
  if ( !s )
    __assert_fail(
      "toencrypt != __null",
      "ubersecurecrypt.cpp",
      0x2Du,
      "int dohash(unsigned char*, unsigned int, unsigned char*)");
  memset(s, 0, size);
  memcpy(s, a1, a2);
  v3 = strlen(v12);
  SHA1(v12, v3, &v11);
  AES_set_encrypt_key(&v11, 128LL, &v10);
  AES_cbc_encrypt(s, v8, size, &v10, &v11, 1LL);
  memcpy(dest, (char *)v8 + size - 16, 0x10uLL);
  result = 0LL;
  v5 = *MK_FP(__FS__, 40LL) ^ v13;
  return result;
}
// 400E90: using guessed type int __fastcall AES_set_encrypt_key(_QWORD, _QWORD, _QWORD);
// 400F00: using guessed type int __fastcall AES_cbc_encrypt(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 400FB0: using guessed type int __fastcall SHA1(_QWORD, _QWORD, _QWORD);

//----- (00000000004027D3) ----------------------------------------------------
__int64 create_challenge_1(void)
{
  int v0; // eax@1

  v0 = rand();
  return ((((unsigned int)((unsigned __int64)v0 >> 32) >> 31) + (_BYTE)v0) & 1)
       - ((unsigned int)((unsigned __int64)v0 >> 32) >> 31);
}

//----- (00000000004027F3) ----------------------------------------------------
__int64 __fastcall create_forward_secure_tokens(const unsigned __int8 *a1, unsigned int a2, unsigned __int8 *a3, int a4)
{
  int v4; // eax@1
  __int64 result; // rax@4
  __int64 v6; // rbx@4
  unsigned __int8 *v7; // [sp+8h] [bp-848h]@1
  int v8; // [sp+10h] [bp-840h]@1
  signed int v9; // [sp+28h] [bp-828h]@1
  int i; // [sp+2Ch] [bp-824h]@1
  char dest; // [sp+30h] [bp-820h]@1
  char src; // [sp+430h] [bp-420h]@1
  __int64 v13; // [sp+838h] [bp-18h]@1

  v7 = a3;
  v8 = a4;
  v13 = *MK_FP(__FS__, 40LL);
  v9 = a2;
  memcpy(&dest, a1, a2);
  v4 = min(a2, 0x10u);
  memcpy(&src, a1, v4);
  for ( i = 0; i < v8; ++i )
  {
    dohash((unsigned __int8 *)&dest, v9, (unsigned __int8 *)&src);
    memcpy(&dest, &src, 0x10uLL);
    v9 = 16;
  }
  memcpy(v7, &src, 0x10uLL);
  result = 0LL;
  v6 = *MK_FP(__FS__, 40LL) ^ v13;
  return result;
}

//----- (0000000000402929) ----------------------------------------------------
__int64 __fastcall is_it_valid(unsigned __int8 *a1, __int64 a2, unsigned __int8 *a3, unsigned int a4, int a5)
{
  __int64 result; // rax@1
  __int64 v6; // rbx@1
  char s1; // [sp+20h] [bp-30h]@1
  __int64 v8; // [sp+38h] [bp-18h]@1

  v8 = *MK_FP(__FS__, 40LL);
  create_forward_secure_tokens(a3, a4, (unsigned __int8 *)&s1, a5);
  result = memcmp(&s1, a1, 0x10uLL) == 0;
  v6 = *MK_FP(__FS__, 40LL) ^ v8;
  return result;
}

//----- (00000000004029AC) ----------------------------------------------------
__int64 __fastcall convert_moves_to_buffer(char *a1, unsigned int a2, unsigned __int8 *a3, unsigned int *a4)
{
  signed int v4; // eax@4
  unsigned int v6; // [sp+20h] [bp-10h]@1
  unsigned int v7; // [sp+24h] [bp-Ch]@1
  signed int v8; // [sp+28h] [bp-8h]@0
  unsigned int v9; // [sp+2Ch] [bp-4h]@2

  v7 = 0;
  *a4 = 0;
  v6 = 0;
  while ( v6 < a2 )
  {
    v9 = v6 >> 2;
    if ( !(v6 & 3) )
      a3[v9] = 0;
    v4 = a1[v6];
    if ( v4 == 110 )
    {
      v8 = 1;
    }
    else if ( v4 > 110 )
    {
      if ( v4 == 115 )
      {
        v8 = 2;
      }
      else if ( v4 == 119 )
      {
        v8 = 0;
      }
    }
    else if ( v4 == 101 )
    {
      v8 = 3;
    }
    a3[v9] += v8 << 2 * v7;
    *a4 = v9 + 1;
    ++v6;
    v7 = ((((unsigned int)((signed int)(v7 + 1) >> 31) >> 30) + (_BYTE)v7 + 1) & 3)
       - ((unsigned int)((signed int)(v7 + 1) >> 31) >> 30);
  }
  return 0LL;
}

//----- (0000000000402ABD) ----------------------------------------------------
__int64 __fastcall vulnerable_function1(char *a1, int a2)
{
  a1[a2] = 0;
  return 0LL;
}

//----- (0000000000402AE7) ----------------------------------------------------
__int64 init_db(void)
{
  __int64 result; // rax@2
  signed int i; // [sp+Ch] [bp-4h]@3
  signed int j; // [sp+Ch] [bp-4h]@6

  ht = (__int64)calloc(0x400uLL, 0x18uLL);
  if ( ht == 0 )
  {
    result = 0xFFFFFFFFLL;
  }
  else
  {
    for ( i = 0; i <= 1023; ++i )
    {
      *(_DWORD *)(ht + 24LL * i) = 0;
      *(_QWORD *)(ht + 24LL * i + 8) = 0LL;
      *(_QWORD *)(ht + 24LL * i + 16) = 0LL;
    }
    mt[0] = 1LL;
    for ( j = 1; j <= 3; ++j )
      mt[j] = ((unsigned __int16)mt[j - 1] << 8) & 0x300;
    result = 0LL;
  }
  return result;
}
// 605548: using guessed type __int64 ht;
// 605560: using guessed type __int64 mt[];

//----- (0000000000402BF8) ----------------------------------------------------
__int64 __fastcall get_hash(char *a1)
{
  int v1; // ST1C_4@1
  __int64 result; // rax@4
  __int64 v3; // rbx@4
  int v4; // [sp+14h] [bp-84Ch]@1
  signed int i; // [sp+18h] [bp-848h]@1
  char v6[32]; // [sp+20h] [bp-840h]@1
  char dest; // [sp+40h] [bp-820h]@1
  __int64 v8; // [sp+848h] [bp-18h]@1

  v8 = *MK_FP(__FS__, 40LL);
  strncpy(&dest, a1, 0x400uLL);
  v1 = strlen(&dest);
  SHA1(&dest, v1, v6);
  v4 = 0;
  for ( i = 0; i <= 3; ++i )
    v4 += (unsigned __int8)v6[i] * (unsigned int)mt[i];
  result = v4 & 0x3FF;
  v3 = *MK_FP(__FS__, 40LL) ^ v8;
  return result;
}
// 400FB0: using guessed type int __fastcall SHA1(_QWORD, _QWORD, _QWORD);
// 605560: using guessed type __int64 mt[];
// 402BF8: using guessed type char var_840[32];

//----- (0000000000402CEF) ----------------------------------------------------
signed __int64 __fastcall add_user(char *a1, const char *a2, char *a3, __int64 a4)
{
  __int64 v5; // rbx@7
  __int64 v6; // rbx@10
  __int64 v7; // ST30_8@12
  __int64 v8; // [sp+0h] [bp-50h]@1
  char *v9; // [sp+8h] [bp-48h]@1
  int i; // [sp+28h] [bp-28h]@1
  unsigned int v11; // [sp+2Ch] [bp-24h]@1
  __int64 v12; // [sp+30h] [bp-20h]@1
  __int64 v13; // [sp+38h] [bp-18h]@13

  v9 = a3;
  v8 = a4;
  pthread_mutex_lock(&dblock);
  v11 = get_hash(a1);
  v12 = *(_QWORD *)(ht + 24LL * v11 + 8);
  for ( i = 0; *(_DWORD *)(ht + 24LL * v11) > i; ++i )
  {
    if ( !strncmp((const char *)(v12 + 12), a1, 0x400uLL) )
    {
      pthread_mutex_unlock(&dblock);
      return 4294967293LL;
    }
    v12 = *(_QWORD *)(v12 + 3088);
  }
  if ( *(_QWORD *)(ht + 24LL * v11 + 8) )
  {
    v6 = *(_QWORD *)(ht + 24LL * v11 + 16);
    *(_QWORD *)(v6 + 3088) = malloc(0xC20uLL);
    if ( *(_QWORD *)(v6 + 3088) == 0LL )
    {
      pthread_mutex_unlock(&dblock);
      return 4294967293LL;
    }
    v7 = *(_QWORD *)(*(_QWORD *)(ht + 24LL * v11 + 16) + 3088LL);
    *(_QWORD *)(v7 + 3088) = 0LL;
    *(_QWORD *)(ht + 24LL * v11 + 16) = v7;
  }
  else
  {
    v5 = ht + 24LL * v11;
    *(_QWORD *)(v5 + 8) = malloc(0xC20uLL);
    if ( *(_QWORD *)(v5 + 8) == 0LL )
    {
      pthread_mutex_unlock(&dblock);
      return 4294967293LL;
    }
    *(_QWORD *)(24LL * v11 + ht + 16) = *(_QWORD *)(ht + 24LL * v11 + 8);
    *(_QWORD *)(*(_QWORD *)(ht + 24LL * v11 + 16) + 3088LL) = 0LL;
  }
  ++*(_DWORD *)(ht + 24LL * v11);
  v13 = *(_QWORD *)(ht + 24LL * v11 + 16);
  if ( oldest )
  {
    *(_QWORD *)(newest + 3096) = v13;
    newest = v13;
  }
  else
  {
    oldest = *(_QWORD *)(ht + 24LL * v11 + 16);
    newest = v13;
  }
  strncpy((char *)(v13 + 12), a1, 0x400uLL);
  strncpy((char *)(v13 + 1037), a2, 0x400uLL);
  strncpy((char *)(v13 + 2062), v9, 0x400uLL);
  ++uid;
  *(_DWORD *)(v13 + 8) = uid;
  *(_QWORD *)v13 = time(0LL);
  *(_QWORD *)(v13 + 3088) = 0LL;
  *(_QWORD *)(v13 + 3096) = 0LL;
  *(_QWORD *)v8 = malloc(0xC20uLL);
  strncpy((char *)(*(_QWORD *)v8 + 12LL), a1, 0x400uLL);
  strncpy((char *)(*(_QWORD *)v8 + 1037LL), a2, 0x400uLL);
  strncpy((char *)(*(_QWORD *)v8 + 2062LL), v9, 0x400uLL);
  *(_DWORD *)(*(_QWORD *)v8 + 8LL) = *(_DWORD *)(v13 + 8);
  **(_QWORD **)v8 = *(_QWORD *)v13;
  *(_QWORD *)(*(_QWORD *)v8 + 3088LL) = 0LL;
  *(_QWORD *)(*(_QWORD *)v8 + 3096LL) = 0LL;
  pthread_mutex_unlock(&dblock);
  return 0LL;
}
// 605540: using guessed type int uid;
// 605548: using guessed type __int64 ht;
// 605580: using guessed type __int64 oldest;
// 605588: using guessed type __int64 newest;

//----- (000000000040313B) ----------------------------------------------------
__int64 __fastcall check_cred(char *a1, const char *a2, __int64 a3)
{
  __int64 v3; // rdx@6
  __int64 v4; // rax@6
  __int64 v6; // [sp+8h] [bp-38h]@1
  int i; // [sp+2Ch] [bp-14h]@1
  signed int v8; // [sp+30h] [bp-10h]@1
  unsigned int v9; // [sp+34h] [bp-Ch]@1
  __int64 v10; // [sp+38h] [bp-8h]@1

  v6 = a3;
  v8 = -1;
  pthread_mutex_lock(&dblock);
  v9 = get_hash(a1);
  v10 = *(_QWORD *)(ht + 24LL * v9 + 8);
  for ( i = 0; *(_DWORD *)(ht + 24LL * v9) > i; ++i )
  {
    if ( !strncmp((const char *)(v10 + 12), a1, 0x400uLL) )
    {
      if ( !strncmp((const char *)(v10 + 1037), a2, 0x400uLL) )
      {
        *(_QWORD *)v6 = malloc(0xC20uLL);
        if ( *(_QWORD *)v6 )
        {
          strncpy((char *)(*(_QWORD *)v6 + 12LL), (const char *)(v10 + 12), 0x400uLL);
          strncpy((char *)(*(_QWORD *)v6 + 1037LL), (const char *)(v10 + 1037), 0x400uLL);
          strncpy((char *)(*(_QWORD *)v6 + 2062LL), (const char *)(v10 + 2062), 0x400uLL);
          **(_QWORD **)v6 = *(_QWORD *)v10;
          *(_DWORD *)(*(_QWORD *)v6 + 8LL) = *(_DWORD *)(v10 + 8);
          v3 = *(_QWORD *)v6;
          v4 = *(_QWORD *)v6;
          *(_QWORD *)(v4 + 3096) = 0LL;
          *(_QWORD *)(v3 + 3088) = *(_QWORD *)(v4 + 3096);
          v8 = 0;
        }
        else
        {
          v8 = -3;
        }
      }
      else
      {
        v8 = -2;
        *(_QWORD *)v6 = 0LL;
      }
      break;
    }
    v10 = *(_QWORD *)(v10 + 3088);
  }
  pthread_mutex_unlock(&dblock);
  return (unsigned int)v8;
}
// 605548: using guessed type __int64 ht;

//----- (0000000000403339) ----------------------------------------------------
int __fastcall remove_older_than(int a1)
{
  int v1; // eax@2
  void *ptr; // ST28_8@2
  time_t v4; // [sp+20h] [bp-10h]@1

  v4 = time(0LL);
  pthread_mutex_lock(&dblock);
  while ( oldest && v4 - *(_QWORD *)oldest > a1 )
  {
    v1 = get_hash((char *)(oldest + 12));
    *(_QWORD *)(ht + 24LL * v1 + 8) = *(_QWORD *)(oldest + 3088);
    --*(_DWORD *)(ht + 24LL * v1);
    ptr = (void *)oldest;
    oldest = *(_QWORD *)(oldest + 3096);
    free(ptr);
  }
  return pthread_mutex_unlock(&dblock);
}
// 605548: using guessed type __int64 ht;
// 605580: using guessed type __int64 oldest;

//----- (000000000040342E) ----------------------------------------------------
__int64 __fastcall get_user_cred(char *a1)
{
  int i; // [sp+18h] [bp-18h]@1
  int v3; // [sp+1Ch] [bp-14h]@1
  __int64 v4; // [sp+20h] [bp-10h]@1
  __int64 v5; // [sp+28h] [bp-8h]@1

  pthread_mutex_lock(&dblock);
  v3 = get_hash(a1);
  v4 = *(_QWORD *)(ht + 24LL * v3 + 8);
  v5 = 0LL;
  for ( i = 0; *(_DWORD *)(ht + 24LL * v3) > i; ++i )
  {
    if ( !strncmp((const char *)(v4 + 12), a1, 0x400uLL) )
    {
      v5 = v4;
      break;
    }
    v4 = *(_QWORD *)(v4 + 3088);
  }
  pthread_mutex_unlock(&dblock);
  return v5;
}
// 605548: using guessed type __int64 ht;

//----- (00000000004034FA) ----------------------------------------------------
void set_init_epoch(void)
{
  starting_epoch = 1386316800;
}
// 6055C8: using guessed type int starting_epoch;

//----- (000000000040350A) ----------------------------------------------------
__int64 get_current_epoch(void)
{
  return (unsigned int)(rand() % 500);
}

//----- (0000000000403536) ----------------------------------------------------
void *__fastcall recv_str(__int64 a1)
{
  char buf; // [sp+1Fh] [bp-11h]@2
  int i; // [sp+20h] [bp-10h]@1
  int v4; // [sp+24h] [bp-Ch]@2
  void *ptr; // [sp+28h] [bp-8h]@1

  ptr = calloc(0x401uLL, 1uLL);
  for ( i = 0; i <= 1023; i += v4 )
  {
    v4 = recv(*(_DWORD *)(a1 + 4), &buf, 1uLL, 0);
    if ( v4 <= 0 )
    {
      free(ptr);
      return 0LL;
    }
    if ( 10 == buf || 13 == buf )
      break;
    *((_BYTE *)ptr + i) = buf;
  }
  *((_BYTE *)ptr + i) = 0;
  return ptr;
}

//----- (00000000004035F0) ----------------------------------------------------
int __fastcall _libc_csu_init(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v3; // r13@1
  __int64 v4; // rbx@1
  signed __int64 v5; // rbp@1
  int result; // eax@1

  v3 = a3;
  v4 = 0LL;
  v5 = &_do_global_dtors_aux_fini_array_entry - _frame_dummy_init_array_entry;
  result = init_proc();
  if ( v5 )
  {
    do
      result = ((int (__fastcall *)(_QWORD, __int64, __int64))_frame_dummy_init_array_entry[v4++])(a1, a2, v3);
    while ( v4 != v5 );
  }
  return result;
}
// 604DF0: using guessed type __int64 (__fastcall *_frame_dummy_init_array_entry[2])();
// 604DF8: using guessed type __int64 (__fastcall *_do_global_dtors_aux_fini_array_entry)();

//----- (0000000000403664) ----------------------------------------------------
void term_proc()
{
  ;
}

#error "There were 1 decompilation failure(s) on 35 function(s)"
